<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tab.html">
<link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../bower_components/iron-form/iron-form.html">

<link rel="import" href="../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../bower_components/iron-icons/hardware-icons.html">
<link rel="import" href="../bower_components/iron-icons/editor-icons.html">

<link rel="import" href="../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">

<link rel="import" href="../bower_components/baselib/baselib.html">

<link rel="import" href="../bower_components/polymer-fx/fx-page.html">
<link rel="import" href="../bower_components/polymer-fx/fx-common-behavior.html">

<link rel="import" href="torque-db-behavior.html">
<link rel="import" href="torque-common-behavior.html">
<link rel="import" href="torque-page-behavior.html">
<link rel="import" href="torque-language-behavior.html">

<link rel="import" href="shared-styles.html">

<link rel="import" href="elem-customer-selector.html">

<dom-module id="page-pos2">
  <template>
    <style include="shared-styles">
      :host {
        font-size: 12px;
      }

      .column {
        min-width: 320px;
        min-height: 70vh;
        background: #e1f5fe;
        position: relative;
        margin-left: 2px;
        margin-right: 2px;
      }

      .placeholder {
        background: #b6bdc0;
        padding: 12px;
        text-align: center;
      }

      paper-tabs.view-selector {
        --paper-tabs: {
          background-color: var(--app-primary-color);
          color: white;
        }
      }

      .multi-column-header-row {}

      .multi-column-header {
        cursor: pointer;
        text-align: center;
        margin: 16px 0;
        text-decoration: underline;
      }

      .single-column-tabs-row {}

      .single-column-tab {
        cursor: pointer;
        text-align: center;
        margin: 16px 0;
      }

      .single-column-tab.selected {
        text-decoration: underline;
      }
    </style>

    <elem-not-ready is-ready="[[isReady]]"></elem-not-ready>

    <div class$="page-fullwidth layout vertical [[$if(isReady, '', 'hidden')]]" id="wrapper">

      <!-- header - start -->

      <!-- header - Multi Column - Start -->
      <template is="dom-if" if="[[isMultiColumn]]">
        <div class="horizontal layout multi-column-header-row">
          <div class="flex multi-column-header">Products</div>
          <div class="flex multi-column-header">Customer</div>
          <div class="flex multi-column-header">Payment</div>
        </div>
      </template>
      <!-- header - Multi Column - End -->

      <!-- header - Single Column - Start -->
      <template is="dom-if" if="[[!isMultiColumn]]">
        <div class="horizontal layout single-column-tabs-row">
          <div class$="flex single-column-tab [[$getTabSelectedClass('products', selectedTabName)]]" data-key="products" on-tap="singleColumnTabTapped">Products</div>
          <div class$="flex single-column-tab [[$getTabSelectedClass('customer', selectedTabName)]]" data-key="customer" on-tap="singleColumnTabTapped">Customer</div>
          <div class$="flex single-column-tab [[$getTabSelectedClass('payment', selectedTabName)]]" data-key="payment" on-tap="singleColumnTabTapped">Payment</div>
        </div>
      </template>
      <!-- header - Single Column - End -->

      <!-- header - end -->

      <!-- columns - Start -->
      <div class="horizontal layout">

        <!-- products column - start -->
        <div class$="column flex [[$getColumnClasses('products', 'real', isMultiColumn, selectedTabName)]]">

          <!-- warehouse selection - start -->
          <template is="dom-if" if="[[hasModule('MOD_SELL_WAREHOUSE_PRODUCTS')]]">
            <template is="dom-if" if="[[$shouldShowWarehouseSelector(warehouseList.length, productList.length)]]">
              <div class="card">
                <paper-dropdown-menu class="full-width-paper-dropdown" label="[[verses.pos.selectProductsFromInventoryContainer]]" class="mr-4">
                  <paper-listbox slot="dropdown-content" selected="{{selectedWarehouse}}" attr-for-selected="name">
                    <paper-item name="--current-outlet">[[verses.pos.currentOutlet]]</paper-item>
                    <template is="dom-repeat" items="[[warehouseList]]" as="warehouse">
                      <paper-item name="[[warehouse.id]]">
                        <div class="name">[[warehouse.name]]</div>
                      </paper-item>
                    </template>
                  </paper-listbox>
                </paper-dropdown-menu>
              </div>
            </template>
          </template>
          <!-- warehouse selection - end -->

          <!-- product searchbar - start -->
          <div class="card vertical layout">
            <div class="horizontal layout center">
              <paper-input class="flex" value="{{productSearchString}}" always-float-label label="Name/Identifirer Code of product" on-keypress="productSearchFieldKeypressed"></paper-input>
              <paper-icon-button icon="search" on-tap="productSearchTapped"></paper-icon-button>
            </div>
          </div>
          <!-- product searchbar - end -->

          <!-- selected product list - start -->
          <template is="dom-if" if="[[hasModule('MOD_PRODUCT')]]">
            <template is="dom-if" if="[[productList.length]]">

              <div class="card vertical layout">
                <div style="font-weight: bold;">Selected Products:</div>
                <div class="list">

                  <template is="dom-repeat" items="[[productList]]" as="product">
                    <div class="horizontal layout item center">
                      <div class="vertical layout flex">
                        <div>
                          <span class="product-title">[[product.name]]</span>
                        </div>
                        <div class="horizontal layout center">
                          <div class="description">[[product.selectedCount]] [[product.unit]] @&nbsp;</div>
                          <div>[[product.salePrice]]</div>
                          <div class="description">[[app.settings.monetaryUnit]]</div>
                          <span class="product-discount-vat-detail"> (+ [[verses.pos.vat]]: {{product.vatValue}}%)</span>
                        </div>
                      </div>
                      <template is="dom-if" if="[[hasPrivilege('PRIV_ALLOW_FLEXIBLE_PRICE', organization)]]">
                        <paper-icon-button on-tap="editProductSalePriceTapped" icon="create"></paper-icon-button>
                      </template>
                    </div>
                  </template>

                </div>
              </div>

            </template>
          </template>
          <!-- selected product list - end -->

        </div>
        <!-- products column - end -->

        <!-- customer column - start -->
        <div class$="column flex [[$getColumnClasses('customer', 'real', isMultiColumn, selectedTabName)]]">
          <div class="card horizontal layout center">
            Customer TBD
          </div>
        </div>
        <div class$="column flex placeholder  vertical layout center-center [[$getColumnClasses('customer', 'placeholder', isMultiColumn, selectedTabName)]]">
          <div>
            Please complete product/service selection to access customer features.
          </div>
        </div>
        <!-- customer column - end -->

        <!-- payment column - start -->
        <div class$="column flex [[$getColumnClasses('payment', 'real', isMultiColumn, selectedTabName)]]">
          <div class="card horizontal layout center">
            Payment TBD
          </div>
        </div>
        <div class$="column flex placeholder vertical layout center-center  [[$getColumnClasses('payment', 'placeholder', isMultiColumn, selectedTabName)]]">
          <div>
            Please complete product/service and customer selection to access payment features.
          </div>
        </div>
        <!-- payment column - end -->

      </div>
      <!-- columns - End -->

    </div>

  </template>

  <script>
    class PagePos2 extends FxPage.mixin(TorqueCommonBehavior, TorquePageBehavior, TorqueDbBehavior, FxCommonBehavior, TorqueLanguageBehavior) {

      static get is() {
        return 'page-pos2';
      }

      static get properties() {
        return {
          // Tabination =============
          isMultiColumn: {
            type: Boolean,
            value: false
          },
          selectedTabName: {
            type: String,
            value: 'products'
          },
          // Products =============
          warehouseList: {
            type: Array,
            value: () => []
          },
          selectedWarehouse: {
            type: String,
            value: '--current-outlet',
            observer: 'selectedWarehouseChanged'
          },
          productsSelectedFromWarehouseId: {
            type: Number,
            value: null,
          },
          productList: {
            type: Array,
            value: () => []
          },
          matchingProductList: {
            type: Array,
            value: () => []
          },
          // Services =============
          serviceList: {
            type: Array,
            value: () => []
          },
          // Customer =============
          isSearchingCustomer: {
            type: Boolean,
            value: false
          },
          customer: {
            type: Object,
            value: null,
            observer: 'customerChanged'
          },
          // Payment =============
          selectedDiscountPreset: {
            type: String,
            value: '--no-discount',
            observer: 'selectedDiscountPresetChanged'
          },
          payment: {
            type: Object,
            value: () => {
              return {
                totalAmount: null,
                vatAmount: 0,
                discountType: 'percent',
                discountValue: 0,
                discountedAmount: 0,
                serviceChargeAmount: 0,
                totalBillBeforeRounding: 0,
                roundedByAmount: 0,
                totalBilled: null,
                shouldSaveChangeInAccount: false,
                paymentMethod: 'cash',
                paidAmount: 0,
                changeAmount: 0
              }
            }
          },
          // Offline Mode =============
          isInOfflineMode: {
            type: Boolean,
            value: false
          },
          shouldExpandOfflineSalesList: {
            type: Boolean,
            value: false
          },
        };
      }

      // region: core =================================

      constructor() {
        super();
        this.confirmPageReady();
      }

      _ensureAccess() {
        return this.accessControl({
          authLevel: 'organization-selected',
          privilegeList: ['PRIV_ACCESS_POS']
        });
      }

      onNavigateIn() {
        this.app.shouldShowSaveButton = false;
        this.app.currentPageIsModal = true;
        this.useLanguageServices();
        this.onOfflineDataChange();
        this.onOrganizationChange(this.app.organization);
        this.app.pushPageTitle(this.app.verses.pos.posPageTitle);
        if (!'outlet' in this.params) {
          return this.app.showModalDialog(this.app.verses.general.errorMessageTitle, this.app.verses.general.somethingWentWrong, () => {
            return this.navigateTo('/home');
          });
        }
        if (!this._ensureAccess()) return;

        // tabination
        this._detectMultiColumnSupport();
        window.addEventListener('resize', () => this._detectMultiColumnSupport());

        // products
        if (!this.isInOfflineMode) {
          this._fetchWarehouseList((warehouseList) => {
            warehouseList.reverse();
            this.warehouseList = warehouseList;
          });
        }
        this.selectedWarehouse = this.app.getFromSession('pos-selected-warehouse') || '--current-outlet';
        this.productsSelectedFromWarehouseId = this.app.getFromSession('product-selected-from-warehouse-id') || null;
        this.productList = this.app.getFromSession('pos-selected-product-list') || [];
        this.matchingProductList = [];

        // services
        this.serviceList = this.app.getFromSession('pos-selected-service-list') || [];

        // customer
        this.delay(0, () => {
          this.self = this;
          let customerId = this.app.extractFromSession('last-created-customer');
          if (customerId !== null) {
            this._processGetCustomer({ customerId }, (customer) => {
              this.customer = customer;
            });
          } else {
            let customer = this.app.getFromSession('last-selected-customer');
            if (customer) {
              this.customer = customer;
            }
          }
        });

        // payment
        this.assignedAssistedByEmployee = this.app.getFromSession('pos-assigned-assisted-by-employee');
        this.selectedDiscountPreset = '--no-discount';
        this._processDiscountPresetList(() => { });
        this.delay(0, () => {
          this._calculatePayment();
        });

        this.isReady = true;
      }

      onNavigateOut() {
        super.onNavigateOut();
        this.app.currentPageAllowsBackButton = true;
        this.app.popPageTitle();
      }

      onOrganizationChange(organization) {
        this.organization = organization;
      }

      backButtonOnTopBarPressed(e = null) {
        this._resetSales();
        this.app.navigateToPreviousUrl('/home');
      }

      // region: tabination =================================

      singleColumnTabTapped(e) {
        e.stopPropagation();
        let attr = e.target.getAttribute('data-key');
        // console.log({ selectedTabName: attr });
        this.selectedTabName = attr;
      }

      $getTabSelectedClass(tabName, selectedTabName) {
        let classNames = '';
        if (tabName === selectedTabName) {
          classNames += 'selected ';
        }
        if (tabName === 'payment') {
          classNames += 'disabled';
        }
        return classNames;
      }

      _detectMultiColumnSupport() {
        const minimumPageWidth = 960;
        const leftSidebarWidth = 280;
        const margins = 2 + 2 + 2 + 2;
        const scrollbars = 25;
        if (window.innerWidth < (minimumPageWidth + leftSidebarWidth + margins + scrollbars)) {
          this.isMultiColumn = false;
        } else {
          this.isMultiColumn = true;
        }
      }

      $getColumnClasses(tabName, type, isMultiColumn, selectedTabName) {
        // console.log({ tabName, type, isMultiColumn, selectedTabName });
        let classNames = '';

        if (tabName === 'customer' && type !== 'placeholder') {
          classNames += 'hidden ';
        } else if (tabName === 'payment' && type !== 'placeholder') {
          classNames += 'hidden ';
        }

        if (isMultiColumn) {
          // todo
        } else {
          if (tabName === selectedTabName) {
            classNames += ''
          } else {
            classNames += 'hidden ';
          }
        }
        return classNames;
      }

      // region: products =================================

      // sub-region: warehouse

      $shouldShowWarehouseSelector(warehouseListLength, productListLength) {
        return (warehouseListLength > 0 && productListLength === 0);
      }

      selectedWarehouseChanged() {
        this.app.storeInSession('pos-selected-warehouse', this.selectedWarehouse);
        this._updateDefaultInventoryId(() => { }); // Makes sure defaultInventoryId is set correctly
      }

      _setProductSelectedFromWarehouseId(id) {
        this.productsSelectedFromWarehouseId = id;
        this.app.storeInSession('product-selected-from-warehouse-id', this.productsSelectedFromWarehouseId);
      }

      _fetchWarehouseList(cbfn) {
        if (!this.hasModule('MOD_SELL_WAREHOUSE_PRODUCTS')) {
          return cbfn([]);
        }
        let data = { organizationId: this.app.organization.id };
        this.app.callGetWarehouseListApi(data, (err, response) => {
          if (err) return;
          if (response.hasError) return this.onApiError(response.error);
          return cbfn(response.warehouseList);
        });
      }

      // sub-region: getting default inventory

      _processGetOutletDefaultInventoryIdOnline(cbfn) {
        let data = { outletId: this.params.outlet };
        this.app.callGetOutletApi(data, (err, response) => {
          if (err) return;
          if (response.hasError) return this.onApiError(response.error);
          return cbfn(response.defaultInventory.id);
        });
      }

      _processGetOutletDefaultInventoryIdOffline(cbfn) {
        window.setTimeout(() => {
          cbfn(this.app.offlineData.cache.getOutlet.defaultInventory.id);
        }, 10);
      }

      _processGetWarehouse(cbfn) {
        let data = { warehouseId: this.selectedWarehouse };
        this.app.callGetWarehouseApi(data, (err, response) => {
          if (err) return;
          if (response.hasError) return this.onApiError(response.error);
          return cbfn(response);
        });
      }

      _processGetOutletDefaultInventoryId(cbfn) {
        if (this.selectedWarehouse === '--current-outlet') {
          this._setProductSelectedFromWarehouseId(null);
          if (this.isInOfflineMode) {
            this._processGetOutletDefaultInventoryIdOffline(cbfn);
          } else {
            this._processGetOutletDefaultInventoryIdOnline(cbfn);
          }
        } else {
          if (this.isInOfflineMode) {
            return this.app.showModalDialog(this.verses.pos.saleNotValid, this.verses.pos.offlineWarehouseSellNotAllowed);
          } else {
            this._processGetWarehouse(({ defaultInventory, warehouse }) => {
              this._setProductSelectedFromWarehouseId(warehouse.id);
              return cbfn(defaultInventory.id);
            });
          }
        }
      }

      _updateDefaultInventoryId(cbfn) {
        this.defaultInventoryId = null;
        this._processGetOutletDefaultInventoryId(defaultInventoryId => {
          this.defaultInventoryId = defaultInventoryId;
          cbfn();
        });
      }

      // sub-region: search

      // _fetchProductMatchingIdentifierCodeOnline(cbfn) {
      //   this._processGetOutletDefaultInventoryId(defaultInventoryId => {

      //     let inventoryId = defaultInventoryId;
      //     this.inventoryId = inventoryId;
      //     let data = { inventoryId, includeZeroCountProducts: false, identifierCode: this.productSearchString };
      //     this.app.callGetAggregatedInventoryDetailsApi(data, (err, response) => {
      //       if (err) return;
      //       if (response.hasError) return this.onApiError(response.error);
      //       return cbfn(response);
      //     });
      //   })
      // }

      // _fetchProductMatchingIdentifierCode(cbfn) {
      //   if (this.isInOfflineMode) {
      //     // FIXME: Remove or Implement
      //     // this._fetchProductMatchingIdentifierCodeOffline(cbfn);
      //   } else {
      //     this._fetchProductMatchingIdentifierCodeOnline(cbfn);
      //   }
      // }

      // _prepareProductForInsertion({ product }) {
      //   let { productId, name, selectedCount, count, salePrice, vatValue, unit } = product;
      //   let maxAllowedCount = count;
      //   selectedCount = parseFloat(String(selectedCount));
      //   let minSalePrice = salePrice;
      //   return { productId, name, selectedCount, maxAllowedCount, salePrice, vatValue, minSalePrice, unit };
      // }

      // _fetchProduct(cbfn) {
      //   this._fetchProductMatchingIdentifierCode(({ aggregatedProductList, inventoryContainerDetails, inventoryDetails }) => {
      //     let productList = aggregatedProductList.map(product => {
      //       let { purchasePrice, salePrice } = product.product;
      //       let { name, unit, defaultVat } = product.product.productBlueprint;
      //       product.isSelected = false;
      //       let vatValue = defaultVat;
      //       Object.assign(product, { name, unit, purchasePrice, salePrice, vatValue });
      //       return product;
      //     });
      //     cbfn(productList);
      //   });
      // }

      // _productIdentifierCodeEntered(e) {

      //   this._fetchProduct((productList) => {
      //     this.identifierCode = '';
      //     if (productList.length === 0) {
      //       this.lastErrorMessage = this.verses.scan.noMatchingProductsError;
      //       return;
      //     }

      //     // NOTE: The following calculation is to ensure products are selected from adjacent batches
      //     let selectedCount = 0;
      //     let calculatedMaxCount = 0;
      //     let product;
      //     for (product of productList) {
      //       calculatedMaxCount += product.count;
      //       let foundProduct = this.selectedProductList.find(selectedProduct => selectedProduct.productId === product.productId);
      //       if (!foundProduct) break;
      //       selectedCount += parseFloat(foundProduct.selectedCount);
      //       if (selectedCount < calculatedMaxCount) break;
      //     }
      //     if (selectedCount === calculatedMaxCount) {
      //       this.lastErrorMessage = this.verses.scan.noMatchingProductsError;
      //       return;
      //     }
      //     // NOTE: end

      //     product = this._prepareProductForInsertion({ product });

      //     let foundProduct = this.selectedProductList.find(selectedProduct => selectedProduct.productId === product.productId);
      //     if (foundProduct) {
      //       foundProduct.selectedCount = parseFloat(foundProduct.selectedCount) + 1;
      //     } else {
      //       product.selectedCount = 1;
      //       this.selectedProductList.push(product);
      //     }
      //     // this.push('productList',product);
      //     this.productList = [];
      //     this.productList = this.selectedProductList;
      //     this.selectedProductCount += 1;
      //     this.lastSuccessMessage = `${this.verses.scan.lastScanned} "${product.name}"`;
      //   })
      // }

      _fetchInventoryDetailsOnline(cbfn) {
        let data = {
          inventoryId: this.defaultInventoryId,
          searchString: String(this.productSearchString),
          paginate: this.paginate,
          includeZeroCountProducts: false,
          sortOrder: 'blueprint-created-date-descending'
        };
        this.app.callGetAggregatedInventoryDetailsApi(data, (err, response) => {
          if (err) return;
          if (response.hasError) return this.onApiError(response.error);
          this.pagination = response.pagination;
          return cbfn(response);
        });
      }

      _fetchInventoryDetailsOffline(cbfn) {
        window.setTimeout(() => {
          let response = JSON.parse(JSON.stringify(this.app.offlineData.cache.getAggregatedInventoryDetails));

          let searchString = String(this.productSearchString);
          if (searchString.length > 0) {
            searchString = searchString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            let regex = new RegExp(searchString, 'g');
            response.aggregatedProductList = response.aggregatedProductList.filter(product => {
              return (regex.test(product.product.productBlueprint.name) || searchString === product.product.productBlueprint.identifierCode);
            });
          }

          ([response.aggregatedProductList, response.pagination] = this._paginateOfflineData(response.aggregatedProductList));

          this.pagination = response.pagination;
          cbfn(response);
        }, 100);
      }

      _fetchInventoryDetails(cbfn) {
        if (this.isInOfflineMode) {
          this._fetchInventoryDetailsOffline(cbfn);
        } else {
          this._fetchInventoryDetailsOnline(cbfn);
        }
      }

      _searchProducts(cbfn) {
        this._fetchInventoryDetails(({ aggregatedProductList, inventoryContainerDetails, inventoryDetails }) => {

          // Prepare Products
          let productList = aggregatedProductList.map(product => {
            let { purchasePrice, salePrice } = product.product;
            let { name, unit, defaultVat, identifierCode } = product.product.productBlueprint;
            let vatValue = defaultVat;
            Object.assign(product, { name, unit, purchasePrice, salePrice, vatValue, identifierCode });
            return product;
          });

          if (productList.length === 1 && this.productSearchString.length > 0 && productList[0].identifierCode === this.productSearchString) {
            // search by identifierCode was successful.
            productList[0].selectedCount = 1;
            this._selectProduct({ product: productList[0] });
            this.productSearchString = '';
          } else {
            this.matchingProductList = productList;
          }

          cbfn();
        });
      }

      _selectProduct({ product }) {
        // console.log("_selectProduct", { product });
        let { productId, name, selectedCount, count, salePrice, vatValue, unit } = product;
        let maxAllowedCount = count;
        selectedCount = parseFloat(String(selectedCount));
        let minSalePrice = salePrice;

        let existingProductIndex = this.productList.findIndex(existingProduct => existingProduct.productId === product.productId);
        if (existingProductIndex > -1) {
          let existingProduct = this.productList[existingProductIndex];
          this.set(`productList.${existingProductIndex}.selectedCount`, (existingProduct.selectedCount + selectedCount));
        } else {
          this.unshift('productList', { productId, name, selectedCount, maxAllowedCount, salePrice, vatValue, minSalePrice, unit });
        }
      }

      productSearchTapped(e = null) {
        this._searchProducts(() => {
          'pass'
        });
      }

      // sub-region: post selection

      editProductSalePriceTapped(e) {
        let { product } = e.model;
        this.app.showModalInput(this.verses.sales.editSalePrice, this.verses.sales.editSalePriceDetails, product.salePrice, (answer) => {
          let salePrice = parseFloat(answer);
          if (salePrice >= 0) {
            e.model.set('product.salePrice', salePrice);
            this._calculatePayment({ resetRounding: true });
          }
        });
      }

      discardProductTapped(e) {
        let { product } = e.model;
      }

      // region: services =================================

      addServiceTapped(e = null) {
        return this.app.navigateTo(`/pos-select-services/outlet:${this.params.outlet}`);
      }
      // region: customer =================================

      changeCustomerTapped(e = null) {
        this.isSearchingCustomer = true;
      }

      createCustomerTapped(e = null) {
        this.app.navigateTo('/edit-customer');
      }

      removeCustomerTapped(e = null) {
        this.customer = null;
        this.app.storeInSession('last-selected-customer', null);
      }

      customerChanged() {
        if (!this.customer) return;
        this.app.storeInSession('last-selected-customer', this.customer);
      }

      _processGetCustomer({ customerId }, cbfn) {
        let data = {
          customerId
        };
        this.app.callGetCustomerApi(data, (err, response) => {
          if (err) return;
          if (response.hasError) return this.onApiError(response.error);
          cbfn(response.customer);
        });
      }


      _customerSelected(customer) {
        this.customer = customer;
        this.isSearchingCustomer = false;
      }

      // region: payment =================================

      paymentMethodSelected(e) {
        // NOTE: The timeout should not be necessary. However, without it
        // the value of this.payment.paymentMethod is not being updated in time.
        window.setTimeout(() => {
          this._calculatePayment();
        }, 100);
      }

      genericPaymentInputChanged(e) {
        this.enforceMinMaxOnPaperInput(e);
        if (e.target.className.indexOf('payment--paidAmount') > -1) {
          this._calculatePayment({ resetRounding: false });
        } else {
          this._calculatePayment();
        }
      }

      selectedDiscountPresetChanged() {
        if (this.selectedDiscountPreset === '--no-discount') {
          this.payment.discountPresetId = null;
          this.payment.discountType = 'percent';
          this.payment.discountValue = '0';
        } else {
          let key = parseInt(String(this.selectedDiscountPreset));
          let discountPreset = this.discountPresetList.find(discountPreset => discountPreset.id === key);
          this.payment.discountPresetId = discountPreset.id;
          this.payment.discountType = discountPreset.discountType;
          this.payment.discountValue = discountPreset.discountValue;
        }
        this._calculatePayment();
      }

      _fetchDiscountPresetList(cbfn) {
        let data = { organizationId: this.app.organization.id };
        this.app.callGetDiscountPresetListApi(data, (err, response) => {
          if (err) return;
          if (response.hasError) return this.onApiError(response.error);
          return cbfn(response.discountPresetList);
        });
      }

      _processDiscountPresetList(cbfn) {
        if (this.isInOfflineMode) return cbfn(null);
        this._fetchDiscountPresetList(discountPresetList => {
          this.discountPresetList = discountPresetList;
          return cbfn();
        });
      }

      getDiscountPresetLabel(discountPreset) {
        let { name, discountType, discountValue } = discountPreset;
        if (discountType === 'percent') {
          return `${name} (${discountValue}%)`;
        } else {
          return `${name} (${discountValue} ${this.app.settings.monetaryUnit})`;
        }
      }

      // main payment calculation method
      _calculatePayment({ resetRounding = true } = {}) {
        let {
          totalAmount,
          vatAmount,
          discountType,
          discountValue,
          discountedAmount,
          serviceChargeAmount,
          totalBillBeforeRounding,
          roundedByAmount,
          totalBilled,
          shouldSaveChangeInAccount,
          paymentMethod,
          paidAmount,
          changeAmount,
          discountPresetId = null
        } = this.payment;

        // setting vatAmount to default value of 0 before calculating vatAmount on a loop
        vatAmount = 0;

        // reducing to find totalProductAmount
        let totalProductAmount = 0;
        totalProductAmount = this.productList.reduce((sum, product) => {
          let { salePrice, selectedCount, vatValue } = product;

          let salePriceForAllSelected = parseFloat(salePrice * selectedCount);

          // adding product vat value to to total vatAmount
          vatAmount += salePriceForAllSelected * (vatValue / 100);

          // the sum to be set as totalProductAmount
          return parseFloat(sum) + salePriceForAllSelected;
        }, 0);

        // reducing to find totalServiceAmount
        let totalServiceAmount = 0;
        totalServiceAmount = this.serviceList.reduce((sum, service) => {
          let { salePrice, vatValue } = service;

          // adding service vat value to to total vatAmount
          vatAmount += salePrice * (vatValue / 100);

          // the sum to be set as totalServiceAmount
          return parseFloat(sum) + parseFloat(salePrice);
        }, 0);

        // totalAmount of service and product sale price(s)
        totalAmount = parseFloat(totalProductAmount) + parseFloat(totalServiceAmount);

        // overall discount calculation
        if (discountValue) {
          if (discountType === 'percent') {
            discountedAmount = totalAmount * (discountValue / 100);
          } else if (discountType === 'fixed') {
            discountedAmount = discountValue;
          }
        }

        // updating totalBilled with calculated totalAmount, vatAmount and discountedAmount
        totalBilled = totalAmount + vatAmount - discountedAmount;
        this.totalBilledCopy = totalBilled;

        // service charge calculation
        if (serviceChargeAmount) {
          totalBilled += parseFloat(serviceChargeAmount);
        }

        // take rounding into account
        if (resetRounding) roundedByAmount = 0;
        totalBillBeforeRounding = totalBilled;
        totalBilled = totalBillBeforeRounding - roundedByAmount;

        // setting the default paid amount equal to total billed
        if (paymentMethod !== 'cash' && paidAmount < 1) {
          paidAmount = totalBilled;
        }

        // calculating change amount, paid amount depending on payment method
        if (paymentMethod === 'change-wallet') {
          changeAmount = 0;
          paidAmount = 0;
        } else {
          if (paidAmount > totalBilled) {
            changeAmount = paidAmount - totalBilled;
          } else {
            changeAmount = 0;
          }
        }

        // returning updated payment info
        this.payment = {
          totalAmount,
          vatAmount,
          discountType,
          discountValue,
          discountedAmount,
          serviceChargeAmount,
          totalBillBeforeRounding,
          roundedByAmount,
          totalBilled,
          paidAmount,
          changeAmount,
          shouldSaveChangeInAccount,
          paymentMethod,
          discountPresetId
        };
      }

      clearRounderByAmountTapped(e = null) {
        this.payment.roundedByAmount = 0;
        this._calculatePayment();
      }

      editTotalBilledTapped(e = null) {
        this.app.showModalInput(this.verses.sales.editBill, this.verses.sales.editBillDetails, this.payment.totalBilled, (answer) => {
          if (parseFloat(answer) > 0) {
            this.payment.roundedByAmount = Math.max(0, (this.payment.totalBillBeforeRounding - parseFloat(answer)));
            this._calculatePayment({ resetRounding: false });
          }
        });
      }

      _processAddSalesOnline(data, cbfn) {
        data.wasOfflineSale = false;
        this.app.callAddSalesApi(data, (err, response) => {
          if (err) return;
          if (response.hasError) return this.onApiError(response.error);
          cbfn(response);
        });
      }

      _processAddSalesOffline(salesData, cbfn) {
        if (salesData.payment.totalBilled > salesData.payment.paidAmount) {
          this.app.showModalDialog(this.verses.general.errorMessageTitle, this.verses.pos.disallowCreditSale);
          return;
        }
        this.app.db.update('offline-data', (({ which }) => which === 'only'), offlineData => {
          if (!offlineData.data.unsyncedSalesIdSeed) offlineData.data.unsyncedSalesIdSeed = 0;
          offlineData.data.unsyncedSalesIdSeed += 1;
          salesData.id = 'OFFLINE-' + offlineData.data.unsyncedSalesIdSeed;
          salesData.createdDatetimeStamp = Date.now();
          offlineData.data.unsyncedSalesList.push(salesData);
          return offlineData;
        });
        cbfn({ salesId: salesData.id });
      }

      _processAddSales(cbfn) {
        let outletId = this.params.outlet;
        let payment = this.payment;

        let customerId = null;
        if (this.customer) {
          customerId = this.customer.id;
        }

        let productList = this.productList.map(product => {
          let { name, productId, selectedCount, salePrice, vatValue } = product;
          let vatPercentage = vatValue;
          let finalProduct = { productId, count: selectedCount, salePrice, vatPercentage };
          if (this.isInOfflineMode) {
            finalProduct.productBlueprintName = name;
            finalProduct.returnedProductCount = 0;
            finalProduct.count = parseInt(String(finalProduct.count));
          }
          return finalProduct;
        });

        let serviceList = this.serviceList.map(service => {
          let { id, salePrice, vatValue, assignedEmploymentId, name } = service;
          let serviceId = id;
          let vatPercentage = vatValue;
          let finalService = { serviceId, salePrice, vatPercentage, assignedEmploymentId };
          if (this.isInOfflineMode) {
            finalService.serviceBlueprintName = name;
          }
          return finalService;
        });

        let assistedByEmployeeId = (this.assignedAssistedByEmployee) ? this.assignedAssistedByEmployee.id : null;

        let productsSelectedFromWarehouseId = this.productsSelectedFromWarehouseId;

        if (this.isInOfflineMode && productsSelectedFromWarehouseId !== null) {
          return this.app.showModalDialog(this.verses.pos.saleNotValid, this.verses.pos.offlineWarehouseSellNotAllowed);
        }

        let data = {
          customerId, outletId, productList, serviceList, assistedByEmployeeId, payment,
          productsSelectedFromWarehouseId
        };

        if (this.isInOfflineMode) {
          this._processAddSalesOffline(data, cbfn);
        } else {
          this._processAddSalesOnline(data, cbfn);
        }
      }

      isDiscountTypePercent(discountType) {
        return (discountType === 'percent');
      }

      isPaymentMethodCash(paymentMethod) {
        return (paymentMethod === 'cash');
      }

      isPaymentMethodChangeWallet(paymentMethod) {
        return (paymentMethod === 'change-wallet');
      }

      isValidCreditSale(customer, totalBilled, paidAmount) {
        return (customer && totalBilled > paidAmount);
      }

      // region: finalize & offline mode =================================

      _resetSales({ refreshCurrentPage = true } = {}) {
        this.selectedDiscountPreset = '--no-discount';
        this.selectedWarehouse = '--current-outlet';
        this.productsSelectedFromWarehouseId = null;

        this.app.extractFromSession('pos-selected-warehouse');
        this.app.extractFromSession('product-selected-from-warehouse-id');

        this.app.extractFromSession('pos-selected-product-list');
        this.app.extractFromSession('pos-selected-service-list');

        this.app.extractFromSession('last-selected-customer');

        this.app.extractFromSession('pos-assigned-assisted-by-employee');

        this.resetProperties('payment', 'productList', 'serviceList', 'customer', 'isSearchingCustomer');

        if (refreshCurrentPage) {
          this.app.refreshCurrentPage();
        }
      }

      saveSaleTapped(e = null) {
        this._processAddSales(({ salesId }) => {
          let message = this.app.verses.pos.newSalesAdded;
          this.app.showToast(message, _ => {
            this._resetSales();
          });
        });
      }

      saveSaleAndPrintTapped(e = null) {
        this._processAddSales(({ salesId }) => {
          this._resetSales();
          return this.app.navigateTo(`/print-sales-receipt/sales:${salesId}/from:pos`);
        });
      }

      toggleAllOfflineSalesTapped(e = null) {
        this.shouldExpandOfflineSalesList = !this.shouldExpandOfflineSalesList;
      }

      printOfflineSalesTapped(e) {
        return this.app.navigateTo(`/print-sales-receipt/sales:${e.model.unsyncedSales.id}/from:pos`);
      }

      discardOfflineSalesTapped(e) {
        let salesId = e.model.unsyncedSales.id;
        this.app.db.update('offline-data', (({ which }) => which === 'only'), offlineData => {
          let index = offlineData.data.unsyncedSalesList.findIndex(sales => sales.id === salesId);
          if (index > -1) {
            offlineData.data.unsyncedSalesList.splice(index, 1);
          }
          return offlineData;
        });
      }

      _submitAnOfflineSales(unsyncedSales, cbfn) {
        unsyncedSales = JSON.parse(JSON.stringify(unsyncedSales));

        // Remove temporarily added properties (that were required for offline preview)
        unsyncedSales.productList.forEach(product => {
          delete product.productBlueprintName;
          delete product.returnedProductCount;
        });
        unsyncedSales.serviceList.forEach(service => {
          delete service.serviceBlueprintName;
        });
        delete unsyncedSales.id;
        delete unsyncedSales.createdDatetimeStamp;

        unsyncedSales.wasOfflineSale = true;
        this.app.callAddSalesApi(unsyncedSales, (err, response) => {
          if (err) return cbfn(err, null, null);
          if (response.hasError) {
            return this.onApiError(response.error, null, () => {
              return cbfn(null, response.error, null);
            });
          }
          cbfn(null, null, response);
        });
      }

      goOnlineTapped() {
        if (this.isInOfflineMode) {
          this.app.callUserAssertApiKeyApi({}, (err, response) => {
            if (err) {
              this.app.showModalDialog(this.verses.root.networkErrorTitle, this.verses.root.networkErrorContent);
              return;
            }
            this.app.toggleOfflineMode();
          });
        }
      }

      submitAllOfflineSalesTapped(e) {
        let list = this.offlineData.data.unsyncedSalesList;
        let left = list.length;
        const submitNext = () => {
          if (!left) {
            if (this.isInOfflineMode) {
              this.app.toggleOfflineMode();
            }
            return;
          }

          left -= 1;
          let unsyncedSales = list[left];

          this._submitAnOfflineSales(unsyncedSales, (networkError, validationError, response) => {
            if (networkError) {
              return;
            }
            if (validationError) return submitNext();

            this.app.db.update('offline-data', (({ which }) => which === 'only'), offlineData => {
              let index = offlineData.data.unsyncedSalesList.findIndex(sales => sales.id === unsyncedSales.id);
              if (index > -1) {
                offlineData.data.unsyncedSalesList.splice(index, 1);
              }
              return offlineData;
            });

            submitNext();
          });

        }
        submitNext();
      }

      onOfflineDataChange() {
        this.isInOfflineMode = this.app.isInOfflineMode;
        this.offlineData = this.app.offlineData;

        // NOTE: Willingly written in an expressive manner
        if (this.isInOfflineMode) {
          this.app.currentPageAllowsBackButton = false;
        } else {
          this.app.currentPageAllowsBackButton = true;
        }
      }

      // region: misc =================================

      productListOrServiceListHasElement(productListLength, serviceListLength) {
        return (productListLength || serviceListLength);
      }

      assignEmployeeTapped(e) {
        let { id } = e.model.service;
        return this.app.navigateTo(`/pos-assign-employee-service/service:${id}`);
      }

      assignAssistedByEmployeeTapped() {
        return this.app.navigateTo(`/pos-assign-assisted-by-employee`);
      }

    }

    window.customElements.define(PagePos2.is, PagePos2);
  </script>
</dom-module>