
let { asyncIf } = require('baselib');

const MongoClient = require('mongodb').MongoClient;
const ObjectId = require('mongodb').ObjectID;

let make = (array, count) => {
  while (array.length < count) {
    array.unshift(undefined);
  }
  return array;
};

class Database {

  constructor({ path, name }) {
    this._mongodbPath = path;
    this._autoGeneratedKeyCollectionName = 'auto-generated-keys';
    this._mongodbDatabaseName = name;
  }

  initialize(cbfn) {
    MongoClient.connect(this._mongodbPath, (err, connection) => {
      if (err) return cbfn(err);
      this._mongodbConnection = connection;
      this._db = connection.db(this._mongodbDatabaseName);
      return cbfn();
    });
  }

  getDatabaseHandle() {
    return this._db;
  }

  // basic operations:

  /**
   * finds data in a collection
   * 
   * @param {any} collectionName 
   * @param {any} query 
   * @param {any} skip  (offset or item index to start from)
   * @param {any} limit (limit number of items)
   * @param {any} sort (mongodb style sort order)
   * @param {any} cbfn
   * @returns 
   * array of data
   */
  find(collectionName, query, ...args) {
    let [skip = 0, limit = null, sort = null, cbfn] = make(args, 4);
    try {
      let cursor = this._db.collection(collectionName).find(query);
      if (skip) cursor.skip(skip);
      if (limit) cursor.limit(limit);
      if (sort) cursor.sort(sort);
      cursor.toArray((err, docList) => {
        setImmediate(_ => cbfn(err, docList));
      });
    } catch (_err) {
      let err = _err;
      setImmediate(_ => cbfn(err));
    }
    return;
  }

  /**
  * find data in a collection and return the first match
  * 
  * @param {any} collectionName 
  * @param {any} query 
  * @param {any} skip  (offset or item index to start from)
  * @param {any} sort (mongodb style sort order)
  * @param {any} cbfn
  * @returns 
  * array of data
  */
  findOne(collectionName, query, ...args) {
    let [skip = 0, sort = null, cbfn] = make(args, 3);
    this.find(collectionName, query, skip, 1, sort, (err, docList) => {
      if (err) return cbfn(err);
      if (docList.length === 0) {
        return cbfn(null, null);
      } else if (docList.length === 1) {
        return cbfn(null, docList[0]);
      } else {
        err = new Error("Duplicate result to findOne() call.");
        return cbfn(err);
      }
    });
  }

  insertOne(collectionName, doc, cbfn) {
    this._db.collection(collectionName).insertOne(doc, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.insertedCount === 1));
    });
  }

  insertMany(collectionName, docList, cbfn) {
    this._db.collection(collectionName).insertMany(docList, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, results.insertedCount);
    });
  }

  replaceOne(collectionName, query, doc, cbfn) {
    this._db.collection(collectionName).replaceOne(query, doc, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.matchedCount === 1));
    });
  }

  updateOne(collectionName, query, modifications, cbfn) {
    this._db.collection(collectionName).updateOne(query, modifications, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.matchedCount === 1));
    });
  }

  updateMany(collectionName, query, modifications, cbfn) {
    this._db.collection(collectionName).updateMany(query, modifications, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, results.matchedCount);
    });
  }

  deleteOne(collectionName, query, cbfn) {
    this._db.collection(collectionName).deleteMany(query, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.deletedCount === 1));
    });
  }

  deleteMany(collectionName, query, cbfn) {
    this._db.collection(collectionName).deleteMany(query, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, results.deletedCount);
    });
  }

  findByEmbeddedId(collectionName, _id, cbfn) {
    this.findOne(collectionName, { _id: ObjectId(_id) }, cbfn);
  }

  // utils:

  autoGenerateKey(collectionName, cbfn) {
    this.findOne(this._autoGeneratedKeyCollectionName, { which: 'only' }, (err, doc) => {
      if (err) return cbfn(err);
      let condition = asyncIf(doc);
      condition.else(done => {
        this.insertOne(this._autoGeneratedKeyCollectionName, { which: 'only' }, (err, count) => {
          if (err) return cbfn(err);
          this.findOne(this._autoGeneratedKeyCollectionName, { which: 'only' }, (err, _doc) => {
            if (err) return cbfn(err);
            doc = _doc;
          });
        });
      });
      condition.finally(_ => {
        if (!(collectionName in doc)) {
          doc[collectionName] = 0;
        } else {
          doc[collectionName] += 1;
        }
        this.replaceOne(this._autoGeneratedKeyCollectionName, { which: 'only' }, doc, (err, count) => {
          if (err) return cbfn(err);
          return cbfn(null, doc[collectionName]);
        });
      });
    });
  }

  registerCollection(collectionQualifiedName, CollectionClass) {
    if (Object.keys(this).indexOf(collectionQualifiedName) > -1) {
      throw new Error(`${collectionQualifiedName} is not a valid name or is already registered.`);
    }
    this[collectionQualifiedName] = new CollectionClass(this);
  }

}

exports.Database = Database;