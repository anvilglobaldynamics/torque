
let { asyncIf } = require('baselib');

const MongoClient = require('mongodb').MongoClient;
const ObjectId = require('mongodb').ObjectID;

let make = (array, count) => {
  while (array.length < count) {
    array.unshift(undefined);
  }
  return array;
};

class Database {

  constructor(path) {
    this._mongodbPath = path;
    this._autoGeneratedKeyCollectionName = 'auto-generated-keys';
  }

  __initializeAutoGeneratedKeyIndex(cbfn) {
    this.findOne(this._autoGeneratedKeyCollectionName, { which: 'only' }, (err, doc) => {
      if (err) return cbfn(err);
      if (doc) {
        return cbfn();
      } else {
        this.insertOne(this._autoGeneratedKeyCollectionName, { which: 'only' }, (err, count) => {
          if (err) return cbfn(err);
          if (count < 1) {
            err = new Error("InternalError: Unable to create autoGeneratedKeyCollection");
            return cbfn(err);
          }
          return cbfn();
        });
      }
    });
  }

  initialize(cbfn) {
    MongoClient.connect(this._mongodbPath, (err, db) => {
      if (err) return cbfn(err);
      this._mongodbConnection = db;
      this.__initializeAutoGeneratedKeyIndex((err) => {
        if (err) return cbfn(err);
        return cbfn();
      });
    });
  }

  getDatabaseHandle() {
    if (!this._mongodbConnection) {
      throw new Error("DeveloperError: Premature request for mongodb connection");
    }
    return this._mongodbConnection;
  }

  // basic operations:

  /**
   * finds data in a collection
   * 
   * @param {any} collectionName 
   * @param {any} query 
   * @param {any} skip  (offset or item index to start from)
   * @param {any} limit (limit number of items)
   * @param {any} sort (mongodb style sort order)
   * @param {any} cbfn
   * @returns 
   * array of data
   */
  find(collectionName, query, ...args) {
    let [skip = 0, limit = null, sort = null, cbfn] = make(args, 4);
    if (!sort) {
      sort = { 'id': -1 };
    }
    try {
      let cursor = this._mongodbConnection.collection(collectionName).find(query);
      if (skip) cursor.skip(skip);
      if (limit) cursor.limit(limit);
      if (sort) cursor.sort(sort);
      cursor.toArray((err, docList) => {
        setImmediate(_ => cbfn(err, docList));
      });
    } catch (_err) {
      let err = _err;
      setImmediate(_ => cbfn(err));
    }
    return;
  }

  /**
  * find data in a collection and return the first match
  * 
  * @param {any} collectionName 
  * @param {any} query 
  * @param {any} skip  (offset or item index to start from)
  * @param {any} sort (mongodb style sort order)
  * @param {any} cbfn
  * @returns 
  * array of data
  */
  findOne(collectionName, query, ...args) {
    let [skip = 0, sort = null, cbfn] = make(args, 3);
    this.find(collectionName, query, skip, 1, sort, (err, docList) => {
      if (err) return cbfn(err);
      if (docList.length === 0) {
        return cbfn(null, null);
      } else if (docList.length === 1) {
        return cbfn(null, docList[0]);
      } else {
        err = new Error("Duplicate result to findOne() call.");
        return cbfn(err);
      }
    });
  }

  insertOne(collectionName, doc, cbfn) {
    this._mongodbConnection.collection(collectionName).insertOne(doc, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.insertedCount === 1));
    });
  }

  insertMany(collectionName, docList, cbfn) {
    this._mongodbConnection.collection(collectionName).insertMany(docList, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, results.insertedCount);
    });
  }

  replaceOne(collectionName, query, doc, cbfn) {
    this._mongodbConnection.collection(collectionName).replaceOne(query, doc, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.matchedCount === 1));
    });
  }

  updateOne(collectionName, query, modifications, cbfn) {
    this._mongodbConnection.collection(collectionName).updateOne(query, modifications, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.matchedCount === 1));
    });
  }

  updateMany(collectionName, query, modifications, cbfn) {
    this._mongodbConnection.collection(collectionName).updateMany(query, modifications, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, results.matchedCount);
    });
  }

  deleteOne(collectionName, query, cbfn) {
    this._mongodbConnection.collection(collectionName).deleteMany(query, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, (results.deletedCount === 1));
    });
  }

  deleteMany(collectionName, query, cbfn) {
    this._mongodbConnection.collection(collectionName).deleteMany(query, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, results.deletedCount);
    });
  }

  findByEmbeddedId(collectionName, _id, cbfn) {
    this.findOne(collectionName, { _id: ObjectId(_id) }, cbfn);
  }

  updateAndReturnNew(collectionName, query, modifications, cbfn) {
    this._mongodbConnection.collection(collectionName).findOneAndUpdate(query, modifications, { returnOriginal: false }, (err, results) => {
      if (err) return cbfn(err);
      return cbfn(null, results.value);
    });
  }

  autoGenerateKey(collectionName, cbfn) {
    let query = {
      which: 'only'
    };
    let modifications = {
      $inc: {
        [collectionName]: 1
      }
    };
    this.updateAndReturnNew(this._autoGeneratedKeyCollectionName, query, modifications, (err, doc) => {
      if (err) return cbfn(err);
      return cbfn(null, doc[collectionName]);
    });
  }

  registerCollection(collectionQualifiedName, CollectionClass) {
    if (Object.keys(this).indexOf(collectionQualifiedName) > -1) {
      throw new Error(`${collectionQualifiedName} is not a valid name or is already registered.`);
    }
    this[collectionQualifiedName] = new CollectionClass(this);
  }

}

exports.Database = Database;